<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¢¨ä¼æ˜¥ç§‹ï¼šé®é­”éŒ„ </title>
    <link href="https://fonts.googleapis.com/css2?family=Zhi+Mang+Xing&family=Noto+Serif+TC:wght@700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --ink-black: #0a0a0a;
            --paper-bg: #f3e7d3;
            --cinnabar: #c92a2a;
            --gold: #ffd700;
            --jade: #2b8a3e;
            --shield-glow: #00e5ff; 
            --hp-red: #ff0000; 
            --hp-empty: #444; 
        }

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Noto Serif TC', serif; user-select: none; }
        
        #game-container {
            position: relative; width: 100vw; height: 100vh; overflow: hidden;
            transition: transform 0.1s; 
        }

        #game-border {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            border: 20px solid transparent;
            border-image: url("https://www.transparenttextures.com/patterns/wood-pattern.png") 30 stretch;
            pointer-events: none; z-index: 999;
        }

        /* --- ç‰¹æ•ˆå±¤ --- */
        #ink-blindness {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 20%, #000 90%);
            background-color: rgba(0,0,0,0.95);
            opacity: 0; pointer-events: none; z-index: 900;
            transition: opacity 0.5s;
        }
        .blind-active { opacity: 1 !important; }

        #skill-flash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 215, 0, 0.6);
            opacity: 0; pointer-events: none; z-index: 850;
            transition: opacity 0.3s;
        }
        .flash-active { opacity: 1 !important; }

        /* Combo é¡¯ç¤º (å¢åŠ éæ¸¡æ•ˆæœ) */
        #combo-display {
            position: absolute; top: 20%; left: 5%;
            font-family: 'Zhi Mang Xing'; font-size: 80px; color: var(--gold);
            text-shadow: 0 0 20px #ff0000; z-index: 150;
            opacity: 0; transform: scale(0.5); 
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s;
            pointer-events: none;
        }
        .combo-visible { opacity: 1 !important; transform: scale(1) !important; }
        .combo-pop { transform: scale(1.3) !important; }

        /* æ”»æ“Šå…‰æŸç‰¹æ•ˆ */
        .projectile {
            position: absolute; width: 15px; height: 15px; background: #fff;
            border-radius: 50%; box-shadow: 0 0 15px var(--gold), 0 0 30px #fff;
            z-index: 200; pointer-events: none; transition: transform 0.1s linear;
        }

        /* èƒŒæ™¯ */
        #bg-layer {
            position: absolute; width: 100%; height: 100%; top: 0; left: 0;
            background-size: cover; background-position: center;
            background-color: #333; z-index: 0;
            transition: opacity 1s ease-in-out;
        }
        @keyframes bgMove { 0% { transform: scale(1.0); } 100% { transform: scale(1.15); } }
        .bg-anim { animation: bgMove 30s linear forwards; }

        #scene-layer { position: absolute; width: 100%; height: 100%; perspective: 800px; transform-style: preserve-3d; z-index: 10; }
        .floor { 
            position: absolute; bottom: 0; width: 100%; height: 40%; 
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%);
            transform-origin: bottom; transform: rotateX(60deg); pointer-events: none;
        }

        /* Boss */
        #boss-entity { 
            position: absolute; left: 50%; top: 40%; 
            transform: translate(-50%, -50%) translateZ(-600px); 
            display: flex; flex-direction: column; align-items: center; 
            opacity: 0; transition: opacity 1s, transform 0.5s; z-index: 50; 
        }
        .boss-img { width: 450px; filter: drop-shadow(0 0 30px var(--cinnabar)); animation: bossFloat 4s infinite ease-in-out; }
        .boss-name { font-family: 'Zhi Mang Xing'; font-size: 80px; color: var(--cinnabar); text-shadow: 2px 2px 0 #fff; margin-top: -20px; }
        .boss-hp-frame { width: 600px; height: 30px; background: #222; border: 4px solid #555; margin-bottom: 10px; border-radius: 4px; overflow: hidden; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0000, #800000); transition: width 0.2s; }
        @keyframes bossFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-30px); } }

        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 100; }
        
        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }
        .score-box { background: rgba(0,0,0,0.6); padding: 5px 20px; border: 1px solid var(--gold); color: var(--gold); font-size: 24px; font-weight: bold; font-family: 'Zhi Mang Xing'; }
        .progress-text { color: #fff; font-size: 18px; margin-top: 5px; text-shadow: 1px 1px 2px #000; }

        .bottom-hud { display: flex; flex-direction: column; width: 100%; align-items: center; gap: 8px; pointer-events: auto; }

        .skills-bar { display: flex; gap: 15px; margin-bottom: 5px; }
        .skill-btn { 
            width: 70px; height: 70px; border: 2px solid #555; background: #222; border-radius: 8px; 
            position: relative; overflow: hidden; cursor: pointer; display: flex; justify-content: center; align-items: center; 
            font-family: 'Zhi Mang Xing'; font-size: 28px; color: #666; transition: 0.2s; 
        }
        .skill-key { position: absolute; top: 2px; left: 5px; font-size: 12px; font-family: sans-serif; color: #888; }
        .skill-cooldown { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,0,0,0.8); transition: height 0.1s; z-index: 2; }
        .skill-ready { border-color: var(--gold); color: var(--gold); box-shadow: 0 0 10px var(--gold); }
        .skill-ready:hover { transform: scale(1.1); background: #333; }
        
        .hp-container { width: 600px; height: 25px; position: relative; background: #111; border: 2px solid #5d4037; overflow: hidden; }
        .hp-fill { height: 100%; width: 100%; background: linear-gradient(90deg, var(--jade), #ffff00, var(--cinnabar)); transition: width 0.3s; }
        .hp-text { position: absolute; width: 100%; text-align: center; top: 0px; color: #fff; font-size: 16px; font-weight: bold; text-shadow: 1px 1px 1px #000; z-index: 2; }

        #player-input { 
            width: 500px; padding: 15px; font-size: 32px; text-align: center; font-weight: bold;
            background: rgba(0,0,0,0.8); border: none; border-bottom: 4px solid var(--paper-bg); 
            color: var(--gold); outline: none; align-self: center; font-family: 'Noto Serif TC'; transition: 0.3s;
        }
        .input-locked { border-color: var(--gold) !important; background: rgba(50, 40, 0, 0.8) !important; }

        #status-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 80px; color: red; font-family: 'Zhi Mang Xing'; font-weight: bold; text-shadow: 0 0 20px #000;
            opacity: 0; pointer-events: none; z-index: 150; transition: opacity 0.2s;
        }

        /* --- æ€ªç‰©æ¨£å¼ --- */
        .enemy { position: absolute; transform-style: preserve-3d; display: flex; flex-direction: column; align-items: center; will-change: transform; transition: transform 0.1s linear; }
        
        .enemy-hp-container {
            display: flex; gap: 2px; justify-content: center; margin-bottom: 5px;
            padding: 3px; border-radius: 4px; transition: box-shadow 0.3s;
        }
        .hp-block {
            width: 18px; height: 12px;
            background-color: var(--hp-red); border: 1px solid #500; border-radius: 2px; box-shadow: 0 0 2px #000;
        }
        .hp-block.depleted { background-color: var(--hp-empty); border-color: #222; }

        .enemy-box { 
            background: rgba(20, 20, 20, 0.95); border: 2px solid var(--paper-bg); 
            padding: 15px 25px; border-radius: 8px; text-align: center; min-width: 280px; 
            box-shadow: 0 0 15px rgba(0,0,0,0.8); position: relative;
        }

        .answer-hint {
            display: block; color: #ffd700; font-size: 24px; font-weight: bold; margin-top: 5px;
            text-shadow: 0 0 5px #000; opacity: 0; transition: opacity 0.5s;
        }

        .enemy.shielded .enemy-hp-container {
            background: rgba(0, 229, 255, 0.2);
            box-shadow: 0 0 20px var(--shield-glow), 0 0 10px var(--shield-glow) inset;
            border: 2px solid var(--shield-glow);
        }

        .enemy-img { width: 160px; height: 160px; object-fit: contain; margin-top: 5px; filter: drop-shadow(0 5px 10px #000); }
        .q-text { font-size: 32px; color: #fff; font-weight: bold; margin-bottom: 5px; text-shadow: 2px 2px 0 #000; }
        
        .enemy-locked .enemy-box { border-color: var(--gold); box-shadow: 0 0 20px var(--gold); transform: scale(1.05); }
        .enemy-locked .q-text { color: var(--gold); }

        .enemy.ghost .enemy-img { opacity: 0.8; animation: ghostFloat 2s infinite ease-in-out; }
        @keyframes ghostFloat { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        .overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #intro-screen { background-image: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)), url('bg_hell.webp'); background-size: cover; background-position: center; }
        
        /* æ²è»¸ç‰¹æ•ˆ */
        .crawl-container {
            width: 80%; height: 400px; perspective: 400px; overflow: hidden;
            mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);
            margin-bottom: 20px;
        }
        .crawl-content {
            color: #ffcea0; font-size: 36px; font-weight: bold; text-align: center; line-height: 1.6;
            position: relative; top: 100%;
            transform-origin: 50% 100%;
            transform: rotateX(25deg);
            animation: crawl 45s linear infinite;
        }
        
        /* å‹åˆ©æ™‚çš„æ²è»¸ */
        .victory-crawl {
            color: var(--gold) !important; text-shadow: 0 0 10px #ff4500;
            animation: crawlVictory 40s linear forwards !important;
        }

        @keyframes crawl {
            0% { top: 100%; transform: rotateX(20deg) translateZ(0); opacity: 1; }
            100% { top: -250%; transform: rotateX(25deg) translateZ(-100px); opacity: 0; }
        }
        @keyframes crawlVictory {
            0% { top: 100%; transform: rotateX(20deg) translateZ(0); opacity: 1; }
            100% { top: -200%; transform: rotateX(25deg) translateZ(-100px); opacity: 0; }
        }

        #end-title { font-family: 'Zhi Mang Xing'; font-size: 100px; margin-bottom: 20px; font-weight: 900; text-shadow: 0 0 20px #000; }
        .title { font-family: 'Zhi Mang Xing'; font-size: 100px; color: var(--gold); margin-bottom: 10px; text-shadow: 0 0 20px #ff4500; }
        .btn { padding: 15px 50px; margin: 10px; background: transparent; color: var(--paper-bg); border: 2px solid var(--paper-bg); font-size: 24px; font-weight: bold; cursor: pointer; transition: 0.2s; font-family: 'Noto Serif TC'; }
        .btn:hover { background: var(--cinnabar); border-color: var(--cinnabar); color: #fff; }

        .hidden { display: none !important; }
        .hit-red .enemy-box { background-color: #a00 !important; border-color: #f00 !important; transform: scale(1.1); }
        .dying { animation: deathAnim 0.3s forwards; }
        @keyframes deathAnim { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(2); opacity: 0; } }

        .silenced { background-color: #311 !important; color: #888 !important; pointer-events: none; border-bottom-color: #555 !important; }
        .silenced::placeholder { color: #d00; content: "!!! ç¦è¨€å°å£ !!!"; }

        .shake { animation: shakeAnim 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shakeAnim {
            10%, 90% { transform: translate3d(-4px, 0, 0); }
            20%, 80% { transform: translate3d(6px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
        }

        /* é¾è™æ¦œæ¨£å¼ */
        #leaderboard { width: 60%; margin-top: 20px; border-collapse: collapse; color: #fff; font-size: 24px; }
        #leaderboard th, #leaderboard td { border-bottom: 1px solid #555; padding: 10px; text-align: center; }
        #leaderboard th { color: var(--gold); }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-border"></div>
        <div id="ink-blindness"></div>
        <div id="skill-flash"></div>
        <div id="bg-layer"></div>
        
        <div id="combo-display">é€£æ“Š x 0</div>

        <div id="scene-layer">
            <div class="floor"></div>
            <div id="boss-entity">
                <div class="boss-hp-frame"><div id="boss-hp-fill"></div></div>
                <img src="boss_taotie.webp" alt="é¥•é¤®" class="boss-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <div style="font-size:200px; display:none;">ğŸ‘¹</div>
                <div class="boss-name">é¥•é¤®</div>
            </div>
        </div>

        <div id="fx-layer" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:90;"></div>

        <div id="ui-layer">
            <div class="top-bar">
                <div>
                    <div class="score-box">åŠŸç¸¾: <span id="score">0</span></div>
                    <div class="progress-text" id="boss-progress">è·é›¢ Boss: å°šé¤˜ 20 éš»</div>
                </div>
                <div style="color:var(--gold); font-size:24px; font-weight:bold;">ç¬¬ <span id="bg-index">1</span> æ™¯</div>
            </div>
            
            <div id="status-msg"></div>

            <div class="bottom-hud">
                <div class="skills-bar">
                    <div class="skill-btn skill-ready" id="skill-q" onclick="castSkill('f1')"><span class="skill-key">Q</span>æ»…<div class="skill-cooldown" id="cd-q"></div></div>
                    <div class="skill-btn skill-ready" id="skill-w" onclick="castSkill('f2')"><span class="skill-key">W</span>å®š<div class="skill-cooldown" id="cd-w"></div></div>
                    <div class="skill-btn skill-ready" id="skill-e" onclick="castSkill('f3')"><span class="skill-key">E</span>ç¤º<div class="skill-cooldown" id="cd-e"></div></div>
                    <div class="skill-btn skill-ready" id="skill-r" onclick="castSkill('f4')"><span class="skill-key">R</span>ç™’<div class="skill-cooldown" id="cd-r"></div></div>
                </div>

                <div class="hp-container">
                    <div class="hp-fill" id="hp-fill"></div>
                    <div class="hp-text">å²å†Šå‘½è„ˆ</div>
                </div>
                
                <input type="text" id="player-input" placeholder="åœ¨æ­¤é¡Œå­—..." autocomplete="off">
            </div>
        </div>

        <div id="intro-screen" class="overlay-screen">
            <div class="title">å¢¨ä¼æ˜¥ç§‹</div>
            <div class="crawl-container">
                <div class="crawl-content">
                    <p>ä¸Šå¤ç´€å…ƒ æ··æ²Œåˆé–‹</p>
                    <p>å‡¶ç¸ã€Œé¥•é¤®ã€ç”¦é†’</p>
                    <p>åå™¬æ–‡å­— ç¯¡æ”¹ä¿¡å²</p>
                    <p>è¯å¤æ–‡æ˜ å±åœ¨æ—¦å¤•</p>
                    <br>
                    <p>ä½ ä¹ƒç•¶ä¸–ã€Œå¤ªå²å…¬ã€</p>
                    <p>æ‰‹åŸ·æ˜¥ç§‹ä¹‹ç­†</p>
                    <p>èª“æ­»å®ˆè­·æ­£çµ±å²è§€</p>
                    <br>
                    <p>ç©¿è¶ŠåŸé–€ è¸éåœ’æ—</p>
                    <p>è·¨è¶Šéšªæ©‹ é§è¶³å®¢æ£§</p>
                    <p>ç›´æ—é»ƒé¾ å°å°é­”ç¸</p>
                </div>
            </div>
            <button class="btn" onclick="showDifficulty()">[ æç­†å…¥ä¸– ]</button>
        </div>

        <div id="difficulty-screen" class="overlay-screen hidden">
            <div class="title">é¸æ“‡è©¦ç…‰</div>
            <button class="btn" onclick="startGame('easy')">ç«¥ç”Ÿ (æ¥µæ…¢)</button>
            <button class="btn" onclick="startGame('normal')">é€²å£« (æ™®é€š)</button>
            <button class="btn" style="border-color:var(--cinnabar); color:var(--cinnabar);" onclick="startGame('hard')">ç‹€å…ƒ (æŒ‘æˆ°)</button>
        </div>

        <div id="game-over-screen" class="overlay-screen hidden">
            <div id="victory-scroll" class="crawl-container hidden" style="height: 500px;">
                <div class="crawl-content victory-crawl">
                    <p>å¤ªå²å…¬ ç­†ä¼åƒè»</p>
                    <p>é¥•é¤®å°å° é­”æ°£ç›¡æ•£</p>
                    <p>å²å†Šé‡å…‰ æ­£çµ±å¾—å­˜</p>
                    <br>
                    <p>æ˜¥ç§‹å¤§ç¾© è¬ä¸–æµèŠ³</p>
                    <p>è¯å¤æ–‡æ˜ è–ªç«ç›¸å‚³</p>
                    <br>
                    <p>åŠŸå¾·åœ“æ»¿ æ¦®æ­¸æ•…é‡Œ</p>
                </div>
            </div>

            <div class="title" id="end-title">å²å†Šç›¡æ¯€</div>
            <p id="end-reason" style="font-size: 32px; color: #ccc; margin:10px;">åŸå› </p>
            <p style="font-size: 40px; color: var(--gold);">æœ€çµ‚åŠŸç¸¾: <span id="final-score">0</span></p>
            
            <table id="leaderboard">
                <thead><tr><th>æ’å</th><th>æ—¥æœŸ</th><th>åˆ†æ•¸</th></tr></thead>
                <tbody id="leaderboard-body"></tbody>
            </table>

            <button class="btn" id="restart-btn" onclick="location.reload()">é‡æ–°è¼ªè¿´</button>
        </div>
    </div>

<script>
    // é¡Œåº« (å·²ä¿®æ­£)
    const rawQuestions = [
        { q: "äººæ–‡åˆç¥–?", a: "é»ƒå¸" }, { q: "æ²»æ°´ä¸‰éå®¶é–€è€Œä¸å…¥?", a: "å¤§ç¦¹" }, { q: "å‚³èªªä¸­å°„æ—¥è‹±é›„?", a: "åç¾¿" }, 
        { q: "ä¸­åœ‹ç¬¬ä¸€å€‹ç‹æœ?", a: "å¤æœ" }, { q: "å•†æœäº¡åœ‹æš´å›?", a: "ç´‚ç‹" }, { q: "èª°äººåˆ¶ç¦®ä½œæ¨‚?", a: "å‘¨å…¬" },
        { q: "å‘¨ä»£æ”¿æ²»åˆ¶åº¦?", a: "å°å»º" }, { q: "å‘¨å«¡åº¶ç¹¼æ‰¿åˆ¶åº¦?", a: "å®—æ³•åˆ¶" }, { q: "å‘¨åœŸåœ°åˆ¶åº¦?", a: "äº•ç”°åˆ¶" },
        { q: "æ˜¥ç§‹äº”éœ¸é¦–éœ¸?", a: "é½Šæ¡“å…¬" }, { q: "é½Šæ¡“å…¬å®°ç›¸?", a: "ç®¡ä»²" }, { q: "éœ¸ä¸»å£è™Ÿ?", a: "å°Šç‹æ”˜å¤·" }, /* ä¿®æ­£ 1 */
        { q: "å¤©å­åˆ°è«¸ä¾¯é ˜åœ°è¦–å¯Ÿ?", a: "å·¡ç‹©" }, { q: "è«¸ä¾¯å®šæœŸé¢è¦‹å¤©å­?", a: "æœè¦²" }, { q: "ä¸‰å®¶åˆ†æ™‰ï¼Œæ™‰è¢«åˆ†ç‚º?", a: "éŸ“è¶™é­" },
        { q: "å°å»ºåˆ¶ä¸‹ï¼Œå¤©å­ä»¥ä¸‹çš„æ˜¯?", a: "è«¸ä¾¯" }, { q: "è«¸ä¾¯å…¬ç‚ºå“ªäº”ç­‰?", a: "å…¬ä¾¯ç™¾å­ç”·" }, { q: "å„’å®¶å‰µå§‹äºº?", a: "å­”å­" },
        { q: "å­”å­è¢«ç¨±ç‚º?", a: "è¬ä¸–å¸«è¡¨" }, { q: "ä¸»å¼µæ€§å–„", a: "å­Ÿå­" }, { q: "ä¸»å¼µæ€§æƒ¡?", a: "è€å­" },
        { q: "é“å®¶å‰µå§‹äºº?", a: "è€å­" }, { q: "æ¼¢åˆçµ±æ²»æ€æƒ³?", a: "ç„¡ç‚ºè€Œæ²»" }, { q: "ä¸»å¼µé€é™?", a: "èŠå­" },
        { q: "ä¸»å¼µéæ”»å…¼æ„›çš„æ´¾åˆ¥?", a: "å¢¨å®¶" }, { q: "æ³•å®¶é›†å¤§æˆè€…?", a: "éŸ“é" }, { q: "åˆ†å°æ˜¯ä»¥å“ªç¨®é—œä¿‚ç¶­ç¹«?", a: "è¡€ç·£" },
        { q: "çš‡å¸è‡ªç¨±?", a: "æœ•" }, { q: "ç§¦ä»£ä¸­å¤®å®˜åˆ¶?", a: "ä¸‰å…¬ä¹å¿" }, { q: "ç§¦ä»£åœ°æ–¹åˆ¶åº¦?", a: "éƒ¡ç¸£åˆ¶" },
        { q: "ç§¦çµ±ä¸€çš„æ–‡å­—?", a: "å°ç¯†" }, { q: "ç§¦çµ±ä¸€çš„è²¨å¹£?", a: "åŠå…©éŒ¢" }, { q: "ç§¦ç®åˆ¶æ€æƒ³æ–¹æ³•?", a: "ç„šæ›¸å‘å„’" },
        { q: "ç§¦åŒ—ä¼åŒˆå¥´å°‡é ˜?", a: "è’™æ¬" }, { q: "é˜²ç¦¦åŒˆå¥´å»ºè¨­?", a: "é•·åŸ" }, { q: "ç§¦æœ«èª°äººèµ·ç¾©?", a: "é™³å‹å³å»£" },
        { q: "æŒ‡é¹¿ç‚ºé¦¬?", a: "è¶™é«˜" }, { q: "æ¼¢æœé–‹åœ‹è€…?", a: "åŠ‰é‚¦" }, { q: "æ™¯å¸å‰Šè—©çµæœ?", a: "ä¸ƒåœ‹ä¹‹äº‚" },
        { q: "æ¼¢åˆå°åŒˆå¥´æ”¿ç­–?", a: "å’Œè¦ª" }, { q: "æ¼¢åˆç››ä¸–?", a: "æ–‡æ™¯ä¹‹æ²»" }, { q: "æ¼¢æ­¦å‰Šå¼±è—©åœ‹æ–¹æ³•?", a: "æ¨æ©ä»¤" },
        { q: "æ¼¢ä»£é¸å®˜åˆ¶åº¦?", a: "å¯Ÿèˆ‰åˆ¶" }, { q: "æ¼¢ä»£å‡ºä½¿è¥¿åŸŸ?", a: "å¼µé¨«" }, { q: "çµ²ç¶¢ä¹‹è·¯èµ·é»?", a: "é•·å®‰" },
        { q: "å²è¨˜é«”ä¾‹?", a: "ç´€å‚³é«”" }, { q: "æ¼¢æ­¦è²¡ç”¢å¾µç¨…?", a: "ç®—ç·¡" }, { q: "ç‹è½å»ºç«‹?", a: "æ–°æœ" },
        { q: "æ¼¢æ­¦æ‰“æ“Šå•†äººæ“æ§ç‰©åƒ¹ä¹‹æ³•?", a: "å¹³æº–æ³•" }, { q: "æ¼¢æ­¦å°ˆè³£åˆ¶åº¦è¢«æ‰¹è©•?", a: "èˆ‡æ°‘çˆ­åˆ©" },
        { q: "å®‰æ¼¢å…¬?", a: "ç‹è½" }, { q: "é»ƒå·¾ä¹‹äº‚é ˜è¢–?", a: "å¼µè§’" }, { q: "å¤–æˆšæ“”ä»»ä¹‹é«˜è·?", a: "å¤§å¸é¦¬å¤§å°‡è»" },
        { q: "ä¿¡ä»»ç‹è½çš„å¤ªå?", a: "ç‹æ”¿å›" }, { q: "è‡´ä¸‰åœ‹é¼ç«‹ä¹‹å½¹?", a: "èµ¤å£ä¹‹æˆ°" }, { q: "ä¸‰åœ‹?", a: "é­èœ€å³" },
        { q: "é»ƒå·¾å£è™Ÿ?", a: "è’¼å¤©å·²æ­»" }, { q: "èœ€æ¼¢ä¸ç›¸?", a: "è«¸è‘›äº®" }, { q: "å»ºç«‹è¥¿æ™‰?", a: "å¸é¦¬ç‚" },
        { q: "è¥¿æ™‰å‹•äº‚?", a: "å…«ç‹ä¹‹äº‚" }, { q: "äº”èƒ¡åå…­åœ‹äº‚å±€?", a: "æ°¸å˜‰ä¹‹äº‚" }, { q: "æ¨è¡Œæ¼¢åŒ–æ”¹é©è€…?", a: "å­æ–‡å¸" },
        { q: "å­æ–‡å¸æ¨ç¥Ÿ?", a: "å­" }, { q: "åŒ—é­æ°‘æ—?", a: "é®®å‘" }, { q: "åŒ—é­èˆŠéƒ½?", a: "å¹³åŸ" }, { q: "åŒ—é­é·éƒ½?", a: "æ´›é™½" },
        { q: "åŒ—é­æŒ‰è·å–ä¿¸ä¹‹åˆ¶?", a: "ç­ç¥¿åˆ¶" }, { q: "ä¸Šå“ç„¡å¯’é–€?", a: "ä¸‹å“ç„¡ä¸–æ—" }, { q: "åŒ—é­å‹•äº‚?", a: "å…­é®å…µè®Š" },
        { q: "ä¸–æ—å–å¾—æ”¿æ²»ç‰¹æ¬Šä¹‹åˆ¶?", a: "ä¹å“ä¸­æ­£åˆ¶" }, { q: "ä¸–æ—æ“å¤§é‡åœŸåœ°ä¹‹åˆ¶?", a: "å ç”°ä»¤" }, { q: "ç‹èˆ‡é¦¬?", a: "å…±å¤©ä¸‹" },
        { q: "éš‹æœå»ºç«‹è€…?", a: "æ¥Šå …" }, { q: "éš‹æ–‡å¸æ²»ç¸¾?", a: "é–‹çš‡ä¹‹æ²»" }, { q: "éš‹æ–‡å¸æ‰€é–‹é‹æ²³?", a: "å»£é€šæ¸ " },
        { q: "éš‹ã€Œåˆ‘ç¶±ç°¡è¦ã€çš„æ³•å¾‹?", a: "é–‹çš‡å¾‹" }, { q: "éš‹å¤§è¦æ¨¡æ•´é “æˆ¶ç±?", a: "å¤§ç´¢è²Œé–±" }, { q: "æŒ‰æˆ¶ç­‰å¾µç¨…?", a: "è¼¸ç±æ³•" },
        { q: "å”é«˜ç¥–æ˜¯?", a: "ææ·µ" }, { q: "å”åˆæ”¿è®Š?", a: "ç„æ­¦é–€ä¹‹è®Š" }, { q: "å”å¤ªå®—æ²»ç¸¾?", a: "è²è§€ä¹‹æ²»" },
        { q: "å¤–æ—ç¨±å¤ªå®—ç‚º?", a: "å¤©å¯æ±—" }, { q: "å”ç›´è««åè‡£?", a: "é­å¾µ" }, { q: "å½¢å®¹å”åˆå…©ä½åè‡£çš„æˆèª?", a: "æˆ¿è¬€æœæ–·" },
        { q: "å”å’Œè¦ªåè•ƒå…¬ä¸»?", a: "æ–‡æˆå…¬ä¸»" }, { q: "å”å¥³çš‡å¸?", a: "æ­¦å‰‡å¤©" }, { q: "å”ç„å®—æ²»ç¸¾?", a: "é–‹å…ƒä¹‹æ²»" },
        { q: "å£èœœè…¹åŠ?", a: "ææ—ç”«" }, { q: "å”ä¸‰é®ç¯€åº¦ä½¿?", a: "å®‰ç¥¿å±±" }, { q: "å”ä»£è½‰æ©é»?", a: "å®‰å²ä¹‹äº‚" },
        { q: "å€Ÿå“ªå¤–æ—å…µå¹³å®‰å²ä¹‹äº‚?", a: "å›ç´‡" }, { q: "åå¤§å…µé®å±æ©Ÿ?", a: "å¤–é‡å…§è¼•" }, { q: "å®‰å²äº‚å¾Œæ”¿å±€?", a: "è—©é®å‰²æ“š" },
        { q: "åŠ©å”è‚…å®—å¾—ä½?", a: "æè¼”åœ‹" }, { q: "æè¼”åœ‹èº«åˆ†?", a: "å®¦å®˜" }, { q: "ç‰›é»¨ä»£è¡¨?", a: "ç‰›åƒ§å­º" },
        { q: "æé»¨ä»£è¡¨?", a: "æå¾·è£•" }, { q: "å”æœ«æ°‘è®Š?", a: "é»ƒå·¢ä¹‹äº‚" }, { q: "ç¯¡å”ç¯€åº¦ä½¿?", a: "æœ±æº«" },
        { q: "å°ˆæ©«è—©é®?", a: "æ²³åŒ—ä¸‰é®" }, { q: "å”äº¡æ”¿å±€?", a: "äº”ä»£ååœ‹" }, { q: "é™³æ©‹å…µè®Šåˆå?", a: "é»ƒè¢åŠ èº«" },
        { q: "å®‹å¤ªç¥–?", a: "è¶™åŒ¡èƒ¤" }, { q: "å®´æœƒå¥ªå›å…µæ¬Š?", a: "æ¯é…’é‡‹å…µæ¬Š" }, { q: "å®‹å¼·ä¸­å¤®å¼±åœ°æ–¹ä¹‹ç­–?", a: "å¼·æ¦¦å¼±æ" },
        { q: "äº”ä»£æ”¿é¢¨?", a: "æ­¦äººå°ˆæ”¿" }, { q: "æ…¶æ›†æ–°æ”¿ä¸»æŒè€…?", a: "èŒƒä»²æ·¹" }, { q: "ç†™å¯§è®Šæ³•ä¸»æŒè€…?", a: "ç‹å®‰çŸ³" },
        { q: "åˆ†å‰²å®‹ç›¸è»æ¬Š?", a: "æ¨å¯†ä½¿" }, { q: "åˆ†å‰²å®‹ç›¸è²¡æ¬Š?", a: "ä¸‰å¸ä½¿" }, { q: "å®‹ä»£å‰¯ç›¸?", a: "åƒçŸ¥æ”¿äº‹" },
        { q: "é–åº·ä¹‹é›£?", a: "é‡‘æ»…åŒ—å®‹" }, { q: "å®‹ç›£å¯ŸçŸ¥å·ä¹‹è·?", a: "é€šåˆ¤" }, { q: "ç›¡å¿ å ±åœ‹?", a: "å²³é£›" },
        { q: "æ¢å”æ™‰æ¼¢å‘¨?", a: "äº”ä»£" }, { q: "å®‹ä»£ç›£å¯Ÿæ©Ÿæ§‹?", a: "å°è««" }, { q: "å¸¥ã€æ¼•ã€æ†²ã€å€‰?", a: "å››ç›£å¸" },
        { q: "å®‹ä¸­å¤®è»éšŠ?", a: "ç¦è»" }, { q: "å®‹åœ°æ–¹è»éšŠ?", a: "å»‚è»" }, { q: "æ”¶åœ°æ–¹æ¬Šå®˜å“¡?", a: "è½‰é‹ä½¿" },
        { q: "å®‹åœ°æ–¹ä¸‰ç´šåˆ¶?", a: "è·¯å·ç¸£" }, { q: "å®‹ä»£æ–½æ”¿æ•ˆèƒ½ä½ä¸‹åŸå› ?", a: "æ”¿å‡ºå¤šé–€" }, { q: "å®‹çµ±å…µè¨“ç·´æ©Ÿé—œ?", a: "ä¸‰è¡™" },
        { q: "å®‹æ¯å¹´å‘å¤–æ—è¼¸?", a: "æ­²å¹£" }, { q: "å®‹ä»£çš„çœŸå®°ç›¸æ˜¯?", a: "ä¸­æ›¸é–€ä¸‹" }, { q: "å»ºç«‹å…ƒçš„ç¨®æ—?", a: "è’™å¤" },
        { q: "å…ƒä»£åœ°æ–¹é•·å®˜?", a: "é”é­¯èŠ±èµ¤" }, { q: "å…ƒæœé¦–éƒ½?", a: "å¤§éƒ½" }, { q: "å…ƒè¡Œçœå¯¦éš›é•·å®˜?", a: "å¹³ç« æ”¿äº‹" },
        { q: "æ˜é–‹åœ‹å›ä¸»?", a: "æœ±å…ƒç’‹" }, { q: "æ˜å®°ç›¸æ©Ÿé—œ?", a: "ä¸­æ›¸çœ" }, { q: "æ˜ç‰¹å‹™æ©Ÿæ§‹?", a: "éŒ¦è¡£è¡›" },
        { q: "æ˜ç‡•ç‹?", a: "æœ±æ££" }, { q: "æ˜æˆç¥–é·éƒ½?", a: "åŒ—äº¬" }, { q: "ä¸ƒä¸‹è¥¿æ´‹?", a: "é„­å’Œ" },
        { q: "å»¢ç›¸æ¡ˆä»¶?", a: "èƒ¡æƒŸåº¸" }, { q: "è·ªä¸‹å¥äº‹?", a: "è·ªå°" }, { q: "æ˜æ¸…ä»¥è¨€å…¥ç½ª?", a: "æ–‡å­—ç„" },
        { q: "æˆç¥–æ™‚å¢è¨­çš„ç‰¹å‹™?", a: "æ±å» " }, { q: "æˆç¥–æ”¿è®Š?", a: "é–é›£ä¹‹è®Š" }, { q: "æ˜å®¦å®˜ä»¥å°æ¢æä¾›æ„è¦‹?", a: "ç¥¨æ“¬" },
        { q: "æ˜å®¦å®˜ä»£å¸æ‰¹é–±å¥ç« ?", a: "æ‰¹ç´…" }, { q: "æ²‰è¿·æœ¨å·¥ç©æ„ä¹‹æ˜å›?", a: "æ˜ç†¹å®—" }, { q: "æ˜å®¦å®˜é€šæ›‰æ–‡å¢¨ä¹‹è™•?", a: "å…§æ›¸å ‚" },
        { q: "æ˜å‰Šè—©å›ä¸»?", a: "æ˜æƒ å¸" }, { q: "æ˜ç›£å¯Ÿç™¾å®˜éƒ¨é–€?", a: "éƒ½å¯Ÿé™¢" }, { q: "æ˜å»¢é™¤çš„å®˜å“¡?", a: "å®°ç›¸" },
        { q: "å¤ªç¥–è¦å®šå“ªäº›äººä¸èƒ½å¹²é æ”¿äº‹?", a: "å…§è‡£" }, { q: "å»¢ç›¸åˆæœŸå”åŠ©å›ä¸»ä¹‹å®˜å“¡?", a: "å››è¼”å®˜" },
        { q: "æ˜å¤ªç¥–å‡ºèº«?", a: "å¹³æ°‘" }, { q: "æ˜å¤ªç¥–æ€§æ ¼?", a: "çŒœå¿Œå¤šç–‘" }, { q: "æ¸…è™•ç†è—©éƒ¨éƒ¨é–€?", a: "ç†è—©é™¢" },
        { q: "åœŸå¸å®˜ä¸å†ä¸–è¥²?", a: "æ”¹åœŸæ­¸æµ" }, { q: "åˆ†åŒ–è’™æ—åˆ¶åº¦?", a: "ç›Ÿæ——åˆ¶" }, { q: "å‰µå…«æ——å…µåˆ¶?", a: "åŠªçˆ¾å“ˆèµ¤" },
        { q: "åº·ç†™æ±ºç­–æ©Ÿé—œ?", a: "å—æ›¸æˆ¿" }, { q: "é›æ­£è¨­ç«‹?", a: "è»æ©Ÿè™•" }, { q: "ç”¨å…¶åŠ›è€Œçµ•å…¶æ™º?", a: "è’™å¤æ—" },
        { q: "ä¹¾éš†ä¿®æ›¸?", a: "å››åº«å…¨æ›¸" }, { q: "è»æ©Ÿè™•å¯†ä»¤?", a: "å»·å¯„" }, { q: "å–‡å˜›æ•™é ˜è¢–?", a: "é”è³´å–‡å˜›" },
        { q: "å´‡å…¶æ•™è€ŒæŠ‘å…¶æ”¿?", a: "è—æ—" }, { q: "è¼•å…¶æ•™è€Œé›¢å…¶äºº?", a: "å›æ—" }
    ];

    const rawBossQuestions = [
        { q: "è¥¿å‘¨äº‚äº‹?", a: "ä¸‰ç›£ä¹‹äº‚" }, { q: "å°è‡´ç‹å‘½ä¸è¡Œ?", a: "å¹³ç‹æ±é·" }, { q: "é›†æ³•å®¶ä¹‹å¤§æˆè€…?", a: "éŸ“é" },
        { q: "ç§¦ä»£è² è²¬ç›£å¯Ÿç™¾å®˜çš„å®˜è·?", a: "å¾¡å²å¤§å¤«" }, { q: "æ¼¢æ­¦å¸è¨­ç«‹ç›£ç£åœ°æ–¹å®˜çš„è·ä½?", a: "åˆºå²" },
        { q: "æ¼¢ä»£ç”±åœ°æ–¹æ¨è–¦äººæ‰çš„åˆ¶åº¦?", a: "å¯Ÿèˆ‰åˆ¶" }, { q: "ã€Œï¼Ÿï¼Œç¨å°Šå„’è¡“ã€", a: "ç½·é»œç™¾å®¶" },
        { q: "æ¼¢æ­¦é‡å°å•†äººçš„ç¶“æ¿Ÿæ”¹é©?", a: "æ–°ç¶“æ¿Ÿæ”¿ç­–" }, { q: "ä¹å“ä¸­æ­£åˆ¶é¸æ‹”æ¨™æº–è®Šæˆåªé‡?", a: "å®¶ä¸–" },
        { q: "æ¼¢æ­¦å°ç¦ªçš„åœ°æ–¹?", a: "æ³°å±±" }, { q: "åŒ—é­å°‡çš‡å®¤å§“æ°æ‹“è·‹æ”¹ç‚º?", a: "å…ƒ" }, { q: "æ¼¢æ­¦æ™šå¹´æ”¹éçš„è¨¼æ“š?", a: "è¼ªå°ç½ªå·±è©”" },
        { q: "å”æœè² è²¬æ”¿ä»¤å¯©æ ¸çš„æ©Ÿæ§‹?", a: "é–€ä¸‹çœ" }, { q: "å”æœè² è²¬åŸ·è¡Œæ”¿ä»¤çš„æ©Ÿæ§‹?", a: "å°šæ›¸çœ" },
        { q: "å”åˆç”°åˆ¶ç²¾ç¥?", a: "æˆç”°äºˆæ°‘ç‚ºæ°‘åˆ¶ç”¢" }, { q: "å”åˆå…µåˆ¶ç²¾ç¥?", a: "å…µè¾²åˆä¸€" }, /* ä¿®æ­£ 2 */
        { q: "çŸ³æ•¬ç‘­å‰²è®“?", a: "ç‡•é›²åå…­å·" },
        { q: "å®‹é˜²æ­¦å°‡å°ˆæ¬Šä¹‹ç­–?", a: "æ›´æˆæ³•" }, { q: "æ›´æˆŒæ³•å¼Šç—…?", a: "å…µä¸çŸ¥å°‡å°‡ä¸çŸ¥å…µ" }, { q: "å®‹ä»£ä¸‰å¸?", a: "é¹½éµåº¦æ”¯æˆ¶éƒ¨" },
        { q: "è¡Œä¸­æ›¸çœç‰¹è‰²?", a: "å¼·è€Œä¸å°ˆ" }, { q: "é€šåˆ¤æ“æœ‰çš„æ¬ŠåŠ›?", a: "å‰¯ç½²" }, { q: "å®‹çœŸå®—èˆ‡é¼ç°½è¨‚?", a: "æ¾¶æ·µä¹‹ç›Ÿ" },
        { q: "ä¸‰å†—?", a: "å†—å®˜å†—å…µå†—è²»" },
        { q: "æ˜ã€Œä¸‰å¸ã€?", a: "æ‰¿å®£å¸ƒæ”¿ä½¿å¸" }, { q: "æ˜ç·¨å®šçš„å¤§é‡æ¡ˆä¾‹?", a: "å¤§èª¥" }, { q: "æ˜æ¸…ç§‘èˆ‰æ ¼å¼?", a: "å…«è‚¡æ–‡" },
        { q: "ç›£å¯Ÿå…­éƒ¨å®˜å“¡?", a: "å…­ç§‘çµ¦äº‹ä¸­" }, { q: "é›æ­£ä¸­æ¨æ±ºç­–æ©Ÿé—œ?", a: "è»æ©Ÿè™•" }, { q: "æ¸…å…¥é—œå‰æ±ºç­–æ©Ÿé—œ?", a: "è­°æ”¿ç‹å¤§è‡£æœƒè­°" },
        { q: "æ¸…åˆæ¼¢äººå‹•äº‚?", a: "ä¸‰è—©ä¹‹äº‚" }, { q: "èŠå»·éµ?", a: "æ˜å²æ¡ˆ" }, { q: "æˆ´åä¸–?", a: "å—å±±æ¡ˆ" },
        { q: "ç½®æ­£å¤§å…‰æ˜åŒ¾å¾Œ?", a: "å¯†å„²" }, { q: "æ¸…åˆç”Ÿç”¢åŠè»äº‹çµ„ç¹”?", a: "å…«æ——" }, { q: "åº·ç†™æœ€å°ˆæ©«è¼”è‡£?", a: "é°²æ‹œ" }
    ];

    const questions = rawQuestions.map(i => ({ q: i.q.trim(), a: i.a.trim() }));
    const bossQuestions = rawBossQuestions.map(i => ({ q: i.q.trim(), a: i.a.trim() }));
    
    const recentQuestions = [];

    const bgList = ["bg_gate.webp", "bg_garden.webp", "bg_bridge.webp", "bg_inn.webp"];
    const bgColors = ["linear-gradient(#553300, #111)", "linear-gradient(#003300, #111)", "linear-gradient(#223344, #111)", "linear-gradient(#441100, #111)"];
    const bgBoss = "bg_hell.webp";
    const bgBossColor = "radial-gradient(circle, #400 0%, #000 90%)";

    const state = {
        running: false, score: 0, hp: 100, 
        enemies: [], 
        bossPhase: false, bossHp: 200, bossMax: 200,
        killCount: 0, bossTrigger: 20, 
        speed: 0.6,
        bgIndex: 0, bgTimer: 0,
        skills: { q: true, w: true, e: true, r: true },
        frozen: false,
        lockedTarget: null,
        combo: 0,
        comboHideTimer: null // Combo éš±è—è¨ˆæ™‚å™¨
    };

    const enemyTypes = [
        { type: 'normal',   img: 'enemy_1.webp', hp: 1 },
        { type: 'rusher',   img: 'enemy_2.webp', hp: 1 },
        { type: 'ghost',    img: 'enemy_3.webp', hp: 1 }, 
        { type: 'shield',   img: 'enemy_5.webp', hp: 2 }, 
        { type: 'silencer', img: 'enemy_4.webp', hp: 1 }  
    ];

    const lanes = [-30, 0, 30]; 

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = new AudioContext();
    function playTone(freq, type) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type; o.frequency.value = freq;
        g.gain.value = 0.1; g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.1);
    }
    const Sound = {
        hit: () => playTone(400, 'square'),
        hurt: () => playTone(150, 'sawtooth'),
        win: () => playTone(600, 'sine'),
        skill: () => playTone(800, 'triangle'),
        break: () => playTone(200, 'square'), 
        shoot: () => playTone(600, 'square'),
        steal: () => playTone(300, 'sawtooth')
    };

    function showDifficulty() {
        document.getElementById('intro-screen').classList.add('hidden');
        document.getElementById('difficulty-screen').classList.remove('hidden');
    }

    function startGame(diff) {
        if (diff === 'easy') state.speed = 0.25;
        else if (diff === 'normal') state.speed = 0.5;
        else state.speed = 0.9;

        document.getElementById('difficulty-screen').classList.add('hidden');
        
        state.running = true; state.score = 0; state.hp = 100; state.enemies = [];
        state.bossPhase = false; state.killCount = 0; state.bgIndex = 0; state.bgTimer = 0;
        state.frozen = false;
        state.lockedTarget = null;
        state.combo = 0; updateComboUI();
        
        ['f1','f2','f3','f4'].forEach(k => {
            state.skills[k] = true;
            document.getElementById(`skill-${k}`).classList.add('skill-ready');
            document.getElementById(`cd-${k}`).style.height = '0%';
        });

        changeBackground(0);
        document.getElementById('boss-entity').style.opacity = 0;
        document.getElementById('boss-entity').style.transform = "translate(-50%, -50%) translateZ(-600px)";
        const input = document.getElementById('player-input');
        input.value = '';
        input.focus();
        input.classList.remove('input-locked');
        
        updateBossProgress();
        spawnEnemy(); 
        requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
        if (!state.running) return;

        if (!state.bossPhase) {
            state.bgTimer++;
            if (state.bgTimer > 900) { 
                state.bgTimer = 0;
                state.bgIndex = (state.bgIndex + 1) % bgList.length;
                changeBackground(state.bgIndex);
                document.getElementById('bg-index').innerText = (state.bgIndex + 1);
            }

            if (state.killCount >= state.bossTrigger) {
                if (state.enemies.length === 0) enterBossPhase();
            } else {
                if (state.enemies.length < 3 && Math.random() < 0.02) spawnEnemy();
                if (state.enemies.length === 0) spawnEnemy();
            }
        } else {
            if (state.enemies.length < 2 && Math.random() < 0.03) spawnEnemy(true);
        }

        const toRemove = [];
        state.enemies.forEach(e => {
            if (e.dead) return; 
            
            if (!state.frozen) e.z -= e.speed;

            let scale = 600 / (e.z + 400); 
            if (scale < 0) scale = 0;
            
            e.el.style.transform = `translate(-50%, -50%) scale(${scale})`;
            e.el.style.zIndex = Math.floor(600 - e.z);

            let perspectiveFactor = (600 / (e.z + 600)); 
            let viewX = 50 + (e.lane * perspectiveFactor);
            e.el.style.left = viewX + "%";
            let viewY = 40 + (e.y * perspectiveFactor * 0.5); 
            e.el.style.top = viewY + "%";

            if (e.z <= 0) {
                if (e.type === 'shield') {
                    loseScore(300);
                } else {
                    takeDamage(15);
                }

                if(e.type==='ghost') triggerBlindness();
                if(e.type==='silencer') triggerSilence();
                toRemove.push(e);
            }
        });

        toRemove.forEach(e => removeEnemy(e));
        requestAnimationFrame(gameLoop);
    }

    function spawnEnemy(isBossProjectile = false) {
        let availableLanes = lanes.filter(lane => !state.enemies.some(e => e.lane === lane && e.z > 400));
        
        if (availableLanes.length === 0 && !isBossProjectile) {
            if(state.enemies.length < 3) availableLanes = lanes; 
            else return; 
        }

        let chosenLane = isBossProjectile ? lanes[Math.floor(Math.random() * lanes.length)] : availableLanes[Math.floor(Math.random() * availableLanes.length)];
        
        const pool = isBossProjectile ? bossQuestions : questions;
        let qData;
        let attempts = 0;
        do {
            qData = pool[Math.floor(Math.random() * pool.length)];
            attempts++;
        } while (recentQuestions.includes(qData.q) && attempts < 10);
        
        recentQuestions.push(qData.q);
        if(recentQuestions.length > 5) recentQuestions.shift();

        let typeInfo = enemyTypes[0]; 
        if (!isBossProjectile) {
            const r = Math.random();
            if (r < 0.15) typeInfo = enemyTypes[4]; 
            else if (r < 0.3) typeInfo = enemyTypes[3]; 
            else if (r < 0.45) typeInfo = enemyTypes[2]; 
            else if (r < 0.65) typeInfo = enemyTypes[1]; 
        }

        const el = document.createElement('div');
        el.className = 'enemy';
        if(typeInfo.type === 'shield') el.classList.add('shielded');
        if(typeInfo.type === 'ghost') el.classList.add('ghost');

        let backupIcon = 'ğŸ§Ÿ';
        if(isBossProjectile) backupIcon = 'ğŸ”¥';
        else if(typeInfo.type==='rusher') backupIcon = 'ğŸ';
        else if(typeInfo.type==='ghost') backupIcon = 'ğŸ‘»';
        else if(typeInfo.type==='shield') backupIcon = 'ğŸ›¡ï¸';
        else if(typeInfo.type==='silencer') backupIcon = 'ğŸ˜¶';

        // ç”Ÿæˆè¡€æ¢æ ¼å­
        let hpBlocksHTML = '';
        for(let i=0; i<qData.a.length; i++) {
            hpBlocksHTML += '<div class="hp-block"></div>';
        }

        el.innerHTML = `
            <div class="enemy-hp-container">${hpBlocksHTML}</div>
            <div class="enemy-box">
                <div class="q-text">${qData.q}</div>
                <div class="answer-hint">${qData.a}</div>
            </div>
            <img src="${isBossProjectile ? 'projectile.webp' : typeInfo.img}" class="enemy-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <div style="font-size:100px; display:none; filter:drop-shadow(0 0 5px #000);">${backupIcon}</div>
        `;
        document.getElementById('scene-layer').appendChild(el);

        state.enemies.push({
            id: Date.now() + Math.random(),
            lane: chosenLane, 
            y: isBossProjectile ? -10 : 0,    
            z: 600,           
            speed: isBossProjectile ? state.speed * 1.5 : state.speed * (typeInfo.type==='rusher'?1.5:1),
            hp: isBossProjectile ? 1 : typeInfo.hp,
            currentInput: "", 
            data: qData,
            el: el,
            type: isBossProjectile ? 'projectile' : typeInfo.type,
            dead: false
        });
    }

    function removeEnemy(e) {
        state.enemies = state.enemies.filter(en => en.id !== e.id);
        if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
        if (state.lockedTarget === e.id) {
            state.lockedTarget = null;
            document.getElementById('player-input').classList.remove('input-locked');
        }
    }

    // --- æ‰“å­—é‚è¼¯ ---
    document.getElementById('player-input').addEventListener('input', (e) => {
        if (!state.running) return;
        const inputVal = e.target.value.trim();
        
        if (inputVal === "") {
            state.lockedTarget = null;
            document.getElementById('player-input').classList.remove('input-locked');
            state.enemies.forEach(en => updateEnemyBlocks(en, ""));
            return;
        }

        let target = null;
        if (state.lockedTarget) {
            target = state.enemies.find(en => en.id === state.lockedTarget);
            if (!target || target.dead) {
                state.lockedTarget = null;
                document.getElementById('player-input').classList.remove('input-locked');
                target = null;
            } else if (!target.data.a.startsWith(inputVal)) {
                 shakeScreen();
                 resetCombo(); 
                 e.target.value = "";
                 state.lockedTarget = null;
                 document.getElementById('player-input').classList.remove('input-locked');
                 updateEnemyBlocks(target, "");
                 return;
            }
        }

        if (!target) {
            const candidates = state.enemies.filter(en => !en.dead && en.data.a.startsWith(inputVal));
            if (candidates.length > 0) {
                candidates.sort((a,b) => a.z - b.z);
                target = candidates[0];
                state.lockedTarget = target.id;
                document.getElementById('player-input').classList.add('input-locked');
                state.enemies.forEach(en => { if(en.id !== target.id) updateEnemyBlocks(en, ""); });
            } else {
                shakeScreen();
                resetCombo(); 
                e.target.value = "";
                return;
            }
        }

        if (target) {
            shootBeam(target); 
            Sound.shoot();
            updateEnemyBlocks(target, inputVal); 
            
            // å¼·åŠ›æ“Šé€€ (Knockback)
            target.z += 100;

            if (inputVal === target.data.a) {
                handleKill(target);
                e.target.value = ""; 
                state.lockedTarget = null;
                document.getElementById('player-input').classList.remove('input-locked');
            }
        }
    });

    function updateEnemyBlocks(enemy, currentVal) {
        const blocks = enemy.el.querySelectorAll('.hp-block');
        const typedLen = currentVal.length;
        
        blocks.forEach((blk, idx) => {
            if (idx < typedLen) blk.classList.add('depleted');
            else blk.classList.remove('depleted');
        });
        
        if (state.lockedTarget === enemy.id) {
            enemy.el.classList.add('enemy-locked');
        } else {
            enemy.el.classList.remove('enemy-locked');
        }
    }

    function shootBeam(targetEnemy) {
        const inputRect = document.getElementById('player-input').getBoundingClientRect();
        const startX = inputRect.left + inputRect.width / 2;
        const startY = inputRect.top;

        const beam = document.createElement('div');
        beam.className = 'projectile';
        document.getElementById('fx-layer').appendChild(beam);

        beam.style.left = startX + 'px';
        beam.style.top = startY + 'px';

        const enemyLeft = parseFloat(targetEnemy.el.style.left) / 100 * window.innerWidth;
        const enemyTop = parseFloat(targetEnemy.el.style.top) / 100 * window.innerHeight;

        void beam.offsetWidth;

        beam.style.transform = `translate(${enemyLeft - startX}px, ${enemyTop - startY}px) scale(0.5)`;
        beam.style.opacity = '0'; 

        setTimeout(() => {
            if(beam.parentNode) beam.parentNode.removeChild(beam);
            targetEnemy.el.classList.add('hit-red');
            setTimeout(() => targetEnemy.el.classList.remove('hit-red'), 100);
        }, 100);
    }

    function shakeScreen() {
        const container = document.getElementById('game-container');
        container.classList.remove('shake');
        void container.offsetWidth;
        container.classList.add('shake');
        Sound.hurt(); 
    }

    function handleKill(e) {
        if (e.type === 'shield' && e.el.classList.contains('shielded')) {
            Sound.break();
            e.el.classList.remove('shielded');
            showStatus("ç ´ç›¾ï¼");
            updateEnemyBlocks(e, ""); 
            return; 
        }

        e.dead = true;
        Sound.hit();
        
        state.combo++;
        updateComboUI();
        
        state.score += 100 + (state.combo * 10);
        updateUI();
        
        if (e.type !== 'projectile') {
            state.killCount++;
            updateBossProgress(); 
        } else {
            damageBoss(15);
        }
        
        e.el.classList.add('dying');
        
        setTimeout(() => {
            if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
            removeEnemy(e);
        }, 300);
    }

    // ä¿®æ­£ï¼šCombo UI è‡ªå‹•æ¶ˆå¤±é‚è¼¯
    function updateComboUI() {
        const el = document.getElementById('combo-display');
        
        if (state.combo > 1) {
            el.innerText = "é€£æ“Š x " + state.combo;
            
            // æ¯æ¬¡é€£æ“Šé‡ç½®è¨ˆæ™‚å™¨
            if (state.comboHideTimer) clearTimeout(state.comboHideTimer);
            
            // é¡¯ç¤ºå‹•ç•«
            el.classList.remove('combo-visible');
            el.classList.remove('combo-pop');
            void el.offsetWidth; // trigger reflow
            el.classList.add('combo-visible');
            el.classList.add('combo-pop');
            setTimeout(() => el.classList.remove('combo-pop'), 200);

            // è¨­ç½® 2 ç§’å¾Œæ·¡å‡º
            state.comboHideTimer = setTimeout(() => {
                el.classList.remove('combo-visible');
            }, 2000);
        } else {
            // Combo < 2 ä¸é¡¯ç¤º
            el.classList.remove('combo-visible');
        }
    }

    function resetCombo() {
        state.combo = 0;
        updateComboUI();
    }

    document.addEventListener('keydown', (e) => {
        if (!state.running) return;
        if (['f1','f2','f3','f4'].includes(e.key.toLowerCase())) {
            useSkill(e.key.toLowerCase());
        }
    });

    function useSkill(key) {
        if (!state.skills[key]) return; 

        if (key === 'f1') { 
            showStatus("æ»…ï¼");
            triggerFlash();
            state.enemies.forEach(e => {
                if(!e.dead) handleKill(e);
            });
            startCooldown('q', 15); 
        }
        else if (key === 'f2') { 
            showStatus("å®šï¼");
            state.frozen = true;
            document.getElementById('bg-layer').style.filter = "grayscale(100%)"; 
            setTimeout(() => {
                state.frozen = false;
                document.getElementById('bg-layer').style.filter = "none";
            }, 5000); 
            startCooldown('w', 20);
        }
        else if (key === 'f3') { 
            showStatus("ç¤ºï¼");
            state.enemies.forEach(en => {
                const hint = en.el.querySelector('.answer-hint');
                if(hint) hint.style.opacity = 1;
            });
            setTimeout(() => {
                state.enemies.forEach(en => {
                    const hint = en.el.querySelector('.answer-hint');
                    if(hint) hint.style.opacity = 0;
                });
            }, 5000); 
            startCooldown('e', 10);
        }
        else if (key === 'f4') { 
            state.hp = Math.min(state.hp + 30, 100);
            updateUI();
            showStatus("ç™’ï¼");
            startCooldown('r', 25);
        }
    }

    function startCooldown(key, seconds) {
        state.skills[key] = false;
        const btn = document.getElementById(`skill-${key}`);
        const cdOverlay = document.getElementById(`cd-${key}`);
        btn.classList.remove('skill-ready');
        cdOverlay.style.height = '100%';
        cdOverlay.style.transition = `height ${seconds}s linear`;
        requestAnimationFrame(() => { cdOverlay.style.height = '0%'; });
        setTimeout(() => {
            state.skills[key] = true;
            btn.classList.add('skill-ready');
        }, seconds * 1000);
    }

    function updateBossProgress() {
        const remaining = Math.max(0, state.bossTrigger - state.killCount);
        const text = state.bossPhase ? "Boss æˆ°é¬¥ä¸­ï¼" : `è·é›¢ Boss: å°šé¤˜ ${remaining} éš»`;
        document.getElementById('boss-progress').innerText = text;
    }

    function triggerFlash() {
        const f = document.getElementById('skill-flash');
        f.classList.add('flash-active');
        setTimeout(() => f.classList.remove('flash-active'), 300);
    }
    
    function triggerBlindness() {
        const ink = document.getElementById('ink-blindness');
        ink.classList.add('blind-active');
        showStatus("æ½‘å¢¨è‡´ç›²ï¼");
        setTimeout(() => ink.classList.remove('blind-active'), 3000);
    }

    function triggerSilence() {
        const input = document.getElementById('player-input');
        input.classList.add('silenced');
        input.disabled = true;
        input.value = "";
        input.placeholder = "!!! ç¦è¨€å°å£ !!!";
        showStatus("ç¦è¨€å°å£ï¼");
        setTimeout(() => {
            input.classList.remove('silenced');
            input.disabled = false;
            input.placeholder = "åœ¨æ­¤é¡Œå­—...";
            input.focus();
        }, 2000);
    }

    function showStatus(msg) {
        const el = document.getElementById('status-msg');
        el.innerText = msg;
        el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 1500);
    }

    function takeDamage(amt) {
        shakeScreen(); 
        resetCombo();
        state.hp -= amt;
        document.getElementById('damage-flash').classList.add('flash-active'); 
        setTimeout(() => document.getElementById('damage-flash').classList.remove('flash-active'), 150);
        updateUI();
        if (state.hp <= 0) gameOver("å²è§€å´©å£", false);
    }

    function loseScore(amt) {
        state.score = Math.max(0, state.score - amt);
        updateUI();
        Sound.steal();
        showStatus("åŠŸç¸¾è¢«å¥ªï¼");
        shakeScreen(); 
        resetCombo();
    }

    function changeBackground(index) {
        const bgLayer = document.getElementById('bg-layer');
        bgLayer.style.opacity = 0; 
        setTimeout(() => {
            const imgUrl = `url('${bgList[index]}')`;
            const backupColor = bgColors[index];
            bgLayer.style.backgroundImage = `${imgUrl}, ${backupColor}`;
            bgLayer.classList.remove('bg-anim');
            void bgLayer.offsetWidth; 
            bgLayer.classList.add('bg-anim');
            bgLayer.style.opacity = 1; 
        }, 500); 
    }

    function enterBossPhase() {
        state.bossPhase = true;
        updateBossProgress();
        const bgLayer = document.getElementById('bg-layer');
        bgLayer.style.opacity = 0;
        setTimeout(() => {
            bgLayer.style.backgroundImage = `url('${bgBoss}'), ${bgBossColor}`;
            bgLayer.classList.add('bg-anim');
            bgLayer.style.opacity = 1;
        }, 500);
        const boss = document.getElementById('boss-entity');
        boss.style.opacity = 1;
        boss.style.transform = "translate(-50%, -50%) translateZ(0px)"; 
        
        state.enemies.forEach(e => {
            if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
        });
        state.enemies = [];
        state.lockedTarget = null;
        
        document.getElementById('player-input').placeholder = "æ“Šç¢é¥•é¤®çš„è¬¬è«–ï¼";
        showStatus("é­”ç¸é™è‡¨ï¼");
    }

    function damageBoss(val) {
        state.bossHp -= val;
        document.getElementById('boss-hp-fill').style.width = (state.bossHp / state.bossMax * 100) + "%";
        if (state.bossHp <= 0) gameOver("é¥•é¤®å°å°", true);
    }

    function updateUI() {
        document.getElementById('score').innerText = state.score;
        document.getElementById('hp-fill').style.width = state.hp + "%";
    }

    function saveScore(score) {
        let scores = JSON.parse(localStorage.getItem('mofa_scores') || '[]');
        scores.push({ date: new Date().toLocaleDateString(), score: score });
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 5); 
        localStorage.setItem('mofa_scores', JSON.stringify(scores));
    }

    function renderLeaderboard() {
        const scores = JSON.parse(localStorage.getItem('mofa_scores') || '[]');
        const tbody = document.getElementById('leaderboard-body');
        tbody.innerHTML = scores.map((s, i) => `<tr><td>${i+1}</td><td>${s.date}</td><td>${s.score}</td></tr>`).join('');
    }

    function gameOver(reason, win) {
        state.running = false;
        document.getElementById('game-over-screen').classList.remove('hidden');
        
        saveScore(state.score);
        renderLeaderboard();

        if (win) {
            document.getElementById('victory-scroll').classList.remove('hidden');
            document.getElementById('end-title').innerText = "å¤©ä¸‹å¤§æ²»";
            document.getElementById('end-title').style.color = "var(--gold)";
        } else {
            document.getElementById('victory-scroll').classList.add('hidden');
            document.getElementById('end-title').innerText = "å²å†Šç›¡æ¯€";
            document.getElementById('end-title').style.color = "var(--cinnabar)";
        }

        document.getElementById('end-reason').innerText = reason;
        document.getElementById('final-score').innerText = state.score;
        Sound.win();
    }
</script>
<div id="damage-flash" style="position:fixed;top:0;left:0;width:100%;height:100%;box-shadow:inset 0 0 50px red;pointer-events:none;opacity:0;transition:opacity 0.1s;"></div>
</body>
</html>
